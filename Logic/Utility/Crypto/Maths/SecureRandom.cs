using Crypto.Extensions;
using System;
using System.Security.Cryptography;

namespace Crypto.Maths
{
    /// <summary>
    /// Represents an instance of a secure random number generator; relies on the <see cref="RNGCryptoServiceProvider"/> class by default.
    /// </summary>
    public sealed class SecureRandom : IRandomNumberGenerator
    {
        private readonly RandomNumberGenerator m_randomNumberGenerator;

        /// <summary>
        /// Gets the default <see cref="SecureRandom"/> instance.
        /// </summary>
        public static readonly SecureRandom Default = New();

        /// <summary>
        /// Initializes a new instance of the <see cref="SecureRandom"/> class.
        /// </summary>
        /// <param name="randomNumberGenerator">The random number source.</param>
        private SecureRandom(RandomNumberGenerator randomNumberGenerator) {
            if (randomNumberGenerator.IsNull()) {
                throw new ArgumentNullException(paramName: nameof(randomNumberGenerator));
            }

            m_randomNumberGenerator = randomNumberGenerator;
        }

        /// <summary>
        /// Fill the specified buffer with a string of randomly generated bytes.
        /// </summary>
        /// <param name="buffer">The buffer that will be filled.</param>
        public byte[] GetBytes(byte[] buffer) {
            m_randomNumberGenerator.GetBytes(buffer);

            return buffer;
        }
        /// <summary>
        /// Generates a new buffer and fills it with the specified number of randomly generated bytes.
        /// </summary>
        /// <param name="count">The length of buffer that will be generated.</param>
        public byte[] GetBytes(int count) {
            return GetBytes(new byte[count]);
        }
        /// <summary>
        /// Throws <see cref="NotSupportedException"/>.
        /// </summary>
        public void Jump(long count) {
            throw new NotSupportedException("secure random number generator does not support the jump operation");
        }
        /// <summary>
        /// Generates a uniformly distributed double precision floating point value between the exclusive range (0, 1).
        /// </summary>
        public double NextDouble() {
            return Operations.DoornikDouble(NextInt32(), NextInt32());
        }
        /// <summary>
        /// Generates a uniformly distributed 32-bit signed integer between the range of int.MinValue and int.MaxValue.
        /// </summary>
        public int NextInt32() {
            return BitConverter.ToInt32(GetBytes(sizeof(int)), 0);
        }
        /// <summary>
        /// Generates a uniformly distributed 32-bit signed integer between the inclusive range [x, y].
        /// </summary>
        /// <param name="x">The value of x.</param>
        /// <param name="y">The value of y.</param>
        public int NextInt32(int x, int y) {
            if (x > y) {
                var z = x;

                x = y;
                y = z;
            }

            var range = ((uint)(y - x));

            if (range != uint.MaxValue) {
                return (((int)NextUInt32(exclusiveHigh: (range + 1U))) + x);
            }
            else {
                return NextInt32();
            }
        }
        /// <summary>
        /// Generates a uniformly distributed 64-bit signed integer between the range of long.MinValue and long.MaxValue.
        /// </summary>
        public long NextInt64() {
            return BitConverter.ToInt64(GetBytes(sizeof(long)), 0);
        }
        /// <summary>
        /// Generates a uniformly distributed 64-bit signed integer between the inclusive range [x, y].
        /// </summary>
        /// <param name="x">The value of x.</param>
        /// <param name="y">The value of y.</param>
        public long NextInt64(long x, long y) {
            if (x > y) {
                var z = x;

                x = y;
                y = z;
            }

            var range = ((ulong)(y - x));

            if (range != ulong.MaxValue) {
                return (((long)NextUInt64(exclusiveHigh: (range + 1UL))) + x);
            }
            else {
                return NextInt64();
            }
        }
        /// <summary>
        /// Generates a uniformly distributed single precision floating point value between the exclusive range (0, 1).
        /// </summary>
        public float NextSingle() {
            return Operations.DoornikSingle(NextInt32());
        }
        /// <summary>
        /// Generates a uniformly distributed 32-bit unsigned integer between the range of uint.MinValue and uint.MaxValue.
        /// </summary>
        [CLSCompliant(false)]
        public uint NextUInt32() {
            return BitConverter.ToUInt32(GetBytes(sizeof(uint)), 0);
        }
        /// <summary>
        /// Generates a uniformly distributed 32-bit unsigned integer between the range [x, y].
        /// </summary>
        /// <param name="x">The value of x.</param>
        /// <param name="y">The value of y.</param>
        [CLSCompliant(false)]
        public uint NextUInt32(uint x, uint y) {
            if (x > y) {
                var z = x;

                x = y;
                y = z;
            }

            var range = (y - x);

            if (range != uint.MaxValue) {
                return (NextUInt32(exclusiveHigh: (range + 1U)) + x);
            }
            else {
                return NextUInt32();
            }
        }
        /// <summary>
        /// Generates a uniformly distributed 64-bit unsigned integer between the range of ulong.MinValue and ulong.MaxValue.
        /// </summary>
        [CLSCompliant(false)]
        public ulong NextUInt64() {
            return BitConverter.ToUInt64(GetBytes(sizeof(ulong)), 0);
        }
        /// <summary>
        /// Generates a uniformly distributed 64-bit unsigned integer between the range [x, y].
        /// </summary>
        /// <param name="x">The value of x.</param>
        /// <param name="y">The value of y.</param>
        [CLSCompliant(false)]
        public ulong NextUInt64(ulong x, ulong y) {
            if (x > y) {
                var z = x;

                x = y;
                y = z;
            }

            var range = (y - x);

            if (range != ulong.MaxValue) {
                return (NextUInt64(exclusiveHigh: (range + 1UL)) + x);
            }
            else {
                return NextUInt64();
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SecureRandom"/> class.
        /// </summary>
        /// <param name="randomNumberGenerator">The random number source.</param>
        public static SecureRandom New(RandomNumberGenerator randomNumberGenerator) => new SecureRandom(randomNumberGenerator);
        /// <summary>
        /// Initializes a new instance of the <see cref="SecureRandom"/> class.
        /// </summary>
        public static SecureRandom New() => New(new RNGCryptoServiceProvider());

        private uint NextUInt32(uint exclusiveHigh) {
            var range = (uint.MaxValue - (((uint.MaxValue % exclusiveHigh) + 1) % exclusiveHigh));
            var result = 0U;

            do {
                result = NextUInt32();
            } while (result > range);

            return (result % exclusiveHigh);
        }
        private ulong NextUInt64(ulong exclusiveHigh) {
            var range = (ulong.MaxValue - (((ulong.MaxValue % exclusiveHigh) + 1) % exclusiveHigh));
            var result = 0UL;

            do {
                result = NextUInt64();
            } while (result > range);

            return (result % exclusiveHigh);
        }
    }
}
